---
title: 一个矩阵滤镜
date: 2021-05-18 22:01:14
permalink: /pages/69d9cd/
categories:
  - 学习笔记
tags:
  - 
---



```js
// 定义一个常量2*PI/360，这个常量用来将角度换算为弧度
var deg2radians = Math.PI * 2 / 360;

function MatrixFilter(obj) {

  if (!obj.filters) return;

  var Matrix;

  // 设置obj滤镜样式
  for (p in obj.filters) {
    if (p == 'DXImageTransform.Microsoft.Matrix')
      Matrix = obj.filters['DXImageTransform.Microsoft.Matrix'];
  }

  if (!Matrix) {
    obj.style.filter += 'progid:DXImageTransform.Microsoft.Matrix()';
  }

  Matrix = obj.filters['DXImageTransform.Microsoft.Matrix'];

  // 复制一个矩阵
  this.clone = function(Matrix2D_x) {
    if (Matrix2D_x.M11) Matrix.M11 = Matrix2D_x.M11;
    if (Matrix2D_x.M12) Matrix.M12 = Matrix2D_x.M12;
    if (Matrix2D_x.M21) Matrix.M21 = Matrix2D_x.M21;
    if (Matrix2D_x.M22) Matrix.M22 = Matrix2D_x.M22;
  }

  if (arguments[1]) this.clone(arguments[1]);

  // 用矩阵计算来进行向量旋转

  // 向量旋转过某个角度
  this.rotate = function (deg) {
    rad = deg * deg2radians;
    costheta = Math.cos(rad);
    sintheta = Math.sin(rad);
    var d = new Matrix2D(costheta, -sintheta, sintheta, costheta);
    this.clone(Matrix2D.mul(Matrix, d));
  }

  /**
  * 向量旋转到某个角度
  */
  this.rotateTo = function(deg) {
    rad = deg * deg2radians;
    costheta = Math.cos(rad);
    sintheta = Math.sin(rad);
    var d = new Matrix2D(costheta, -sintheta, sintheta, costheta);
    this.clone(d);
  }

  /**
  * 向量绕点(sx,sy)旋转

  */
  this.rotateAt = function(deg, sx, sy) {
    rad = deg * deg2radians;
    costheta = Math.cos(rad);
    sintheta = Math.sin(rad);
    var d = new Matrix2D(costheta, -sintheta, sintheta, costheta);
    var x = sx - Matrix.Dx;
    var y = sy - Matrix.Dy;
    this.moveTo(x * costheta + y * sintheta - x,  -x * sintheta + y *costheta - y);
    this.clone(Matrix2D.mul(Matrix, d));
  }

  // 向量绕点(sx,sy)旋转到某个角度
  this.rotateToAt = function (deg, sx, sy) {
    rad = deg * deg2radians;
    costheta = Math.cos(rad);
    sintheta = Math.sin(rad);
    var d = new Matrix2D(costheta, -sintheta, sintheta, costheta);
    var x = sx;
    var y = sy;
    this.moveTo(x - (x * costheta - y * sintheta), -(x * sintheta + y * costheta - x));
    this.clone(d);
  }

  // 向量移动到sx,sy点
  this.moveTo = function(sx, sy) {
    Matrix.Dx = sx;
    Matrix.Dy = sy;
  }

  // 转换为矩阵类型
  this.toMatrix2D = function() {
    return Matrix2D(Matrix.M11, Matrix.M12, Matrix.M21, Matrix.M22);
  }

  // 沿x、y轴拉伸
  this.zoomBy = function (sx, sy) {
    var d = new Matrix2D(sx, 0, 0, sy);
    this.clone(Matrix2D.mul(Matrix, d))
  }

  this.toString = function () {
    return '' + Matrix.M11 + ' ' + Matrix.M12 + '\n' + Matrix.M21 + ' ' + Matrix.M22 + '\n';
  }
}




// 2D矩阵类型
function Matrix2D () {
  this.M11 = arguments[0] || 1;
  this.M12 = arguments[1] || 0;
  this.M21 = arguments[2] || 0;
  this.M22 = arguments[3] || 1;

  // 求矩阵交集（叉乘）
  this.mul_Matrix2D = function(Matrix2D_b) {
    var r = new Matrix2D();
    r = Matrix2D.mul(this, Matrix2D_b);
    return r;
  }
  
  this.toString = function () {
    return '' + this.M11 + ' ' + this.M12 + '\n' + this.M21 + ' ' + this.M22 + '\n';
  }

  this.mul = function (Matrix2D_a, Matrix2D_b) {
    var r = new Matrix2D();
    r.M11 = Matrix2D_a.M11 * Matrix2D_b.M11 + Matrix2D_a.M12 * Matrix2D_b.M21;
    r.M12 = Matrix2D_a.M11 * Matrix2D_b.M12 + Matrix2D_a.M12 * Matrix2D_b.M22;
    r.M21 = Matrix2D_a.M21 * Matrix2D_b.M11 + Matrix2D_a.M22 * Matrix2D_b.M21;
    r.M22 = Matrix2D_a.M21 * Matrix2D_b.M12 + Matrix2D_a.M22 * Matrix2D_b.M22;
  }
}


```