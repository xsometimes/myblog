---
title: react hookså­¦ä¹ ç¬”è®°
date: 2021-04-08 14:02:08
permalink: /pages/9d73aa/
categories:
  - å­¦ä¹ ç¬”è®°
tags:
  - react
  - hooks
---

## [How Are Function Components Different from Classes?](https://overreacted.io/how-are-function-components-different-from-classes/)

è¿™ç¯‡æ–‡ç« é€šè¿‡ classç»„ä»¶çš„å†™æ³•å­˜åœ¨çš„ä¸€ç§å¸¸è§çš„bug çš„ä¾‹å­ï¼Œæ¥å¼•å‡º function componentsä¸­é—­åŒ… è¿™ç§è§£å†³æ–¹å¼çš„ç›¸å…³æ€è€ƒã€‚

éƒ¨åˆ†é‡è¦è¯­å¥æ‘˜æŠ„ï¼š
<p align="center" style="margin: 0; padding: 0"><img width="40px" src="./light_blub.jpg" alt="point"></p>

<mark><b>Function components capture the rendered values.</b></mark>

This class method reads from `this.props.user`. Props are immutable in React so they can never change. However, ***`this` is, and has always been, mutable.***

***Closures*** are often avoided because itâ€™s hard to think about a value that can be mutated over time. But in React, `props` and `state` are immutable! (Or at least, itâ€™s a strong recommendation.)

We could then add as many helper functions inside as we want, and they would all use the captured `props` and `state`. Closures to the rescue!
<p align="center" style="margin: 0; padding: 0"><img width="40px" src="./light_blub.jpg" alt="point"></p> what if we want to read the latest props or state that donâ€™t belong to this particular render? What if we want to â€œread them from the futureâ€?

`useRef`: A ref is a way to â€œopt outâ€ of the rendering consistency, and can be handy in some cases.
<p align="center" style="margin: 0; padding: 0"><img width="40px" src="./light_blub.jpg" alt="point"></p>

Generally, you should avoid reading or setting refs during rendering because theyâ€™re mutable. We want to ***keep the rendering predictable***. However, if we want to get the latest value of a particular `props` and `state`, it can be annoying to update the ref manually. 

We could automate it by `useEffect`.

We do the assignment inside an effect so that the ref value only changes after the DOM has been updated. This ensures our mutation doesnâ€™t break features like ***Time Slicing*** and ***Suspense*** which rely on interruptible rendering.
<p align="center" style="margin: 0; padding: 0"><img width="40px" src="./light_blub.jpg" alt="point"></p>
This pattern can also be handy for optimizations â€” such as when `useCallback` identity changes too often. 

`useReducer` is often ***a better solution***.

## [A Complete Guide to useEffect](https://overreacted.io/a-complete-guide-to-useeffect/)

è¿™åŒæ ·ä¹Ÿæ˜¯ä¸€ç¯‡å¥½æ–‡ï¼Œä½œè€…å¼€ç¯‡æå‡ºäº†5ä¸ªé—®é¢˜ï¼š
- How do I replicate `componentDidMount` with `useEffect`?
- How do I correctly fetch data inside `useEffect`? What is []?
- Do I need to specify functions as effect dependencies or not?
- Why do I sometimes get an infinite refetching loop?
- Why do I sometimes get an old `state` or `prop` value inside my effect?

ä½†ä»–çš„è§£ç­”ä¸ä»…ä»…äºæ­¤ã€‚ä»–å¸¦ç»™æˆ‘ä»¬ä¸€ç§æ–°çš„åŒºåˆ«äºclassçš„mental modelã€‚

éƒ¨åˆ†é‡è¦è¯­å¥æ‘˜æŠ„ï¼š
<p align="center" style="margin: 0; padding: 0"><img width="40px" src="./light_blub.jpg" alt="point"></p>

***Each Render Has Its Ownâ€¦ Everything***ï¼ŒåŒ…å«propsã€stateã€effectsã€event handlersã€clean upï¼ˆé”€æ¯ç»„ä»¶æ—¶æ’¤é”€ï¼‰ã€‚

It doesnâ€™t matter whether you read from `props` or `state` â€œearlyâ€ inside of your component.Theyâ€™re not going to change! Inside the scope of a single render, props and state stay the same.

å°±è¿clean upè¯»å–çš„ä¹Ÿæ˜¯å®šä¹‰å®ƒçš„functionä¸­çš„propsã€‚

> React renders UI for {id: 20}.  
> The browser paints. We see the UI for {id: 20} on the screen.  
> React cleans up the effect for {id: 10}.  
> React runs the effect for {id: 20}.  

The effect cleanup doesnâ€™t read the â€œlatestâ€ props, whatever that means. ***It reads props that belong to the render itâ€™s defined in.***

Thatâ€™s what allows React to deal with effects right after painting â€” and make your apps faster by default. The old props are still there if our code needs them.
<p align="center" style="margin: 0; padding: 0"><img width="40px" src="./light_blub.jpg" alt="point"></p>

Be aware that when you want to ***read the future props or state from a function in a past render***, youâ€™re ***swimming against the tide***. æµçš„æ€æƒ³ 
<p align="center" style="margin: 0; padding: 0"><img width="40px" src="./light_blub.jpg" alt="point"></p>

Teaching React to Diff Your Effects

- [...deps]
- use the functional updater form of setState `setCount(c => c + 1)`: remove dependencies
- useReducerï¼šdecoupling updates from actions, (dispatch identity is still guaranteed to be stable between re-renders)
<p align="center" style="margin: 0; padding: 0"><img width="40px" src="./light_blub.jpg" alt="point"></p>
Are Functions Part of the Data Flow?

With `useCallback`, functions can fully participate in the data flow. We can say that if the function inputs changed, the function itself has changed, but if not, it stayed the same. Thanks to the granularity provided by `useCallback`, changes to props ***like `props.fetchData`*** can propagate down automatically.

## [How to fetch data with React Hooks?](https://www.robinwieruch.de/react-hooks-fetch-data)

è¿™ç¯‡æ–‡ç« å¾ˆè¯¦ç»†åœ°è®²äº†æ€ä¹ˆç”¨hooksè¯·æ±‚æ•°æ®çš„è¿‡ç¨‹ï¼Œå…¶ä¸­åŒ…å«loading indicatorã€error handlingã€custom data fetching hookã€ç»“åˆ`useReducer`ï¼ˆsomehow all these states, managed with their own state hook, belong together because they care about the same cause. ï¼‰ã€ç»„ä»¶é”€æ¯æ—¶abort data fetchingç­‰ã€‚

## [Hooks FAQ â€”â€”reactå®˜ç½‘](https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies)

```ts
/**
 * è¯»å–å‰ä¸€ä¸ªçŠ¶æ€çš„hooks
 * useRefåœ¨ç»„ä»¶æ•´ä¸ªfulltimeä¸­persistï¼Œä¿æŒå¼•ç”¨ä¸å˜ï¼›æ‰‹åŠ¨ä¿®æ”¹ref.currentå¹¶ä¸ä¼šè§¦å‘ç»„ä»¶çš„é‡æ–°æ¸²æŸ“
 * å‡½æ•°å¼ç»„ä»¶çš„å£°æ˜å‘¨æœŸå†³å®šï¼šuseEffectçš„æ‰§è¡Œæ˜¯åœ¨jsxçš„æ¸²æŸ“ä¹‹åï¼Œæ˜¯å»¶è¿Ÿæ‰§è¡Œçš„ã€‚ The default behavior for effects is to fire the effect after every completed render. That way an effect is always recreated if one of its dependencies changes.
 * è€Œreturnè¯­å¥æ˜¯åŒæ­¥çš„ï¼Œreturnæ—¶ï¼Œref.currentè¿˜æ˜¯æ—§å€¼prev state
 */
function usePrevious(value) {
  const ref = useRef();
  useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}
```

```ts
/**
 * è¿™æ®µä»£ç çš„å·¥ä½œæµç¨‹å¦‚ä¸‹ï¼š
 * 1. æœ€åˆï¼Œä¸¤è€…éƒ½æ˜¯ç©ºçš„
 * 2. ç”¨æˆ·é”®å…¥ä¸€äº›ä¸œè¥¿ï¼Œé€šè¿‡setValueè§¦å‘çŠ¶æ€æ›´æ”¹
 * 3. è¿™å°†è§¦å‘ä¸€ä¸ªre-renderï¼Œå› æ­¤{value}æ˜¯æ–°å€¼ï¼Œä½†æ˜¯ç”±äºrefå°šæœªæ›´æ–°ï¼Œ{prevValue.current}ä»ç„¶ä½œä¸ºæ—§å€¼å‘ˆç°
 * 4. æ¥ä¸‹æ¥ï¼Œåœ¨æ¸²æŸ“ä¹‹åï¼Œæ•ˆæœè¿è¡Œï¼Œå› ä¸ºå®ƒæœ‰valueä½œä¸ºä¾èµ–é¡¹ã€‚å› æ­¤ï¼Œæ­¤æ•ˆæœä¼šæ›´æ–°refä»¥åŒ…å«å½“å‰çŠ¶æ€å€¼
 * 5. ä½†æ˜¯ï¼Œç”±äºæ›´æ”¹refå€¼ä¸ä¼šè§¦å‘re-renderï¼Œå› æ­¤æ–°å€¼ä¸ä¼šåæ˜ åœ¨å‘ˆç°çš„å†…å®¹ä¸­
*/
function App () {
  const [value, setValue] = useState('');
  const prevValue = useRef('');
  useEffect(() => {
    prevValue.current = value
  }, [value])

  return (<div>
    <input value={value} onChange={e => setValue(e.target.value)} />
    <div>curr valueï¼š{value}</div>
    <div>prev valueï¼š{prevValue.current}</div>
  </div>)
}
/**
 * æ›´å¥½çš„ï¼Œæ‰€æƒ³è®©refå’ŒvalueåŒæ—¶æ›´æ–°ï¼Œå°±æ˜¯åœ¨onChangeå¤„ç†ç¨‹åºä¸­æ›´æ–°refå€¼
 * /
```

## useRefçš„é«˜çº§ç”¨æ³•
Reactä¸­çš„refsæä¾›äº†ä¸€ç§åœ¨ç»„ä»¶çš„æ•´ä¸ªç”Ÿå‘½å‘¨æœŸä¸­å­˜å‚¨å¯å˜å€¼çš„æ–¹æ³•ï¼Œå¹¶ä¸”é€šå¸¸ç”¨äº**ä¸DOMäº¤äº’è€Œæ— éœ€é‡æ–°æ¸²æŸ“ç»„ä»¶**ã€‚

è¢«å¼•ç”¨çš„å¯¹è±¡æœ¬èº«å­˜å‚¨åœ¨`current`å±æ€§ä¸­ï¼Œå®ƒæœ‰ä¸¤ä¸ªå…³é”®æ€§è´¨ï¼š**è¯¥å±æ€§æ˜¯å¯å˜çš„**ï¼›**å®ƒå¯ä»¥åœ¨ç»„ä»¶ç”Ÿå‘½å‘¨æœŸä¸­éšæ—¶æ›´æ”¹**ã€‚

ä»¥ä¸‹è®°å½•`useRef`çš„å‡ ç§ç”¨æ³•ï¼š

#### ç”¨refsç®¡ç†æŒ‰é’®çŠ¶æ€
ä¸useRefæŒ‰é’®ä¸€èµ·ä½¿ç”¨ï¼Œä»è€Œå¯ä»¥æ§åˆ¶**æŒ‰é’®çš„çŠ¶æ€**ï¼ˆï¼Œä¸è¦ä¸ç»„ä»¶çŠ¶æ€æ··æ·†ï¼‰ï¼Œè€Œæ— éœ€é‡æ–°æ¸²æŸ“æ•´ä¸ªç»„ä»¶ã€‚

```ts
refContainer.current.setAttribute('disabled', true);
refContainer.current.removeAttribute('disabled');
```

#### åœ¨ç»„ä»¶commité˜¶æ®µæ­£ç¡®å®ç°useRef

reactç»„ä»¶æ‰§è¡Œçš„ä¸¤ä¸ªé˜¶æ®µï¼š
- æ¸²æŸ“é˜¶æ®µï¼šå¯¹domåšå‡ºå‘ˆç°çš„å˜åŒ–å¹¶è°ƒç”¨æ–¹æ³•ï¼Œå¦‚`componentWillMount`ã€`render`ã€`setState`ç­‰
- æäº¤commité˜¶æ®µï¼šæäº¤æ›´æ”¹ï¼ˆå³å‘ˆç°é˜¶æ®µç¡®å®šï¼‰çš„domï¼Œå¹¶è°ƒç”¨æ–¹æ³•ï¼Œå¦‚`componentDidMount`ã€`componentDidUpdate`ã€å’Œ`componentDidCatch`ç­‰ã€‚

è‹¥è¦å®ç°`å¼•ç”¨`ï¼Œåˆ™æ¸²æŸ“é˜¶æ®µæœ‰æˆ‘ä»¬éœ€è¦å…³æ³¨çš„å…³é”®é—®é¢˜ï¼š**åœ¨æ‰§è¡Œæäº¤é˜¶æ®µä¹‹å‰ï¼Œå¯èƒ½ä¼šå¤šæ¬¡è°ƒç”¨å®ƒâ€”â€”â€”â€”è¿™æ˜¯æœ‰é—®é¢˜çš„ï¼Œä¼šåœ¨æˆ‘ä»¬çš„ç¨‹åºä¸­å¼•å…¥äº†ä¸å¯é¢„æµ‹æ€§å’Œé”™è¯¯çš„å¯èƒ½æ€§ã€‚**

**`å¼•ç”¨`åº”åœ¨æäº¤é˜¶æ®µå®ç°ã€‚**

æäº¤é˜¶æ®µåªèƒ½è°ƒç”¨ä¸€æ¬¡ï¼Œè¿™æ˜¯æˆ‘ä»¬åº”è¯¥å®šä¹‰`å‰¯ä½œç”¨`çš„é˜¶æ®µï¼Œé€šå¸¸æ¥è¯´ï¼Œæˆ‘ä»¬åªå¸Œæœ›å®ä¾‹åŒ–ä¸€æ¬¡ã€‚

ï¼ˆ`å‰¯ä½œç”¨`æ˜¯ä»»ä½•ä¼šå½±å“æ­£åœ¨æ‰§è¡Œçš„å‡½æ•°èŒƒå›´ä¹‹å¤–çš„å†…å®¹çš„ä¸œè¥¿ï¼Œæ¯”å¦‚APIè¯·æ±‚ã€è®¡æ—¶å™¨ç­‰ã€‚ï¼‰

å¯ä»¥ç”¨ä»¥æµ‹è¯•æé†’çš„æœ‰ä¸¤ç§æ–¹å¼ï¼šä½¿ç”¨ä¸¥æ ¼æ¨¡å¼ï¼›åœ¨å¹¶å‘æ¨¡å¼ä¸‹æµ‹è¯•

```tsx

// 1 ä¸¥æ ¼æ¨¡å¼
ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
, document.getElementById('root'));


// 2 å¹¶å‘æ¨¡å¼
ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
, document.getElementById('root'));

```

é¿å…æˆ‘ä»¬ä¸€ç›´åœ¨è®¨è®ºçš„ä¸å¯é¢„æµ‹çš„Refè¡Œä¸ºçš„è§£å†³æ–¹æ¡ˆæ˜¯åœ¨`useEffect`å’Œ`useLayoutEffect`hookå†…å®ç°Refå‰¯ä½œç”¨ã€‚

æ ¹æ®å®˜æ–¹æ–‡æ¡£ï¼Œ**å‡½æ•°ç»„ä»¶ä¸»ä½“å†…éƒ¨çš„æ‰€æœ‰é€»è¾‘éƒ½åœ¨æ¸²æŸ“é˜¶æ®µæ‰§è¡Œ**ï¼Œä¸»ä½“å†…éƒ¨ä¸å…è®¸å‡ºç°è¯¸å¦‚è®¢é˜…ã€è®¡æ—¶å™¨ã€æ—¥å¿—è®°å½•ç­‰å‰¯ä½œç”¨ï¼Œå¦åˆ™ä¼šå¯¼è‡´UIä¸­ä»¤äººå›°æƒ‘çš„é”™è¯¯å’Œä¸ä¸€è‡´ï¼›å¦ä¸€æ–¹é¢ï¼Œåœ¨æµè§ˆå™¨ä¸­æ›´æ–°äº†domåï¼Œ`useEffect`å°†è¿è¡Œä¸€æ¬¡ã€‚æ•…ï¼Œ`useEffect`å°†åœ¨ç»„ä»¶çš„æäº¤é˜¶æ®µè¿è¡Œã€‚

#### 


## å…¶ä»–æ–‡ç« æ¨è
- [ç²¾è¯»ã€Šæ€ä¹ˆç”¨ React Hooks é€ è½®å­ã€‹](https://github.com/ascoders/weekly/blob/master/80.%E7%B2%BE%E8%AF%BB%E3%80%8A%E6%80%8E%E4%B9%88%E7%94%A8%20React%20Hooks%20%E9%80%A0%E8%BD%AE%E5%AD%90%E3%80%8B.md)
- [React è‡ªå®šä¹‰Hooks å®ç”¨æ¡ˆä¾‹](https://juejin.cn/post/6844903918577664007#heading-33)
- [React Hooks æ·±å…¥ç³»åˆ— ï¼ˆreact FAQçš„ç®€å•ç¿»è¯‘ç‰ˆï¼‰](https://muyunyun.cn/posts/32fb0f08/)
- [react-use githubå®ä¾‹](https://github.com/streamich/react-use)

## é—ç•™å›°æƒ‘
1. åœºæ™¯ï¼šåˆ—è¡¨é¡µé¢ï¼Œå¯¹åˆ—è¡¨ä½¿ç”¨useRefä¿æŒæŒä¹…ä½¿ç”¨ï¼Œitemçš„å¢åˆ æœ‰ä¸¤ç§æ–¹æ³•ï¼š1)æ”¹å˜listRefåŸæ•°ç»„ï¼Œä½¿å¾—é¡µé¢domå…ƒç´ çš„é‡ç»˜åªå‘ç”Ÿåœ¨ä¸ªåˆ«itemï¼Œå†æ‰§è¡ŒforceUpdateï¼›2)é€šè¿‡å°è£…useSyncStateï¼Œå°†newValueèµ‹ç»™listRefï¼Œæ­¤æ—¶å¯¹äºä½¿ç”¨keyçš„åˆ—è¡¨æ¸²æŸ“ï¼Œé¡µé¢ä¼šé‡æ–°æ¸²æŸ“listçš„domå…ƒç´ å—ï¼Ÿ






















usePrevious

forceUpdate



useEffect

The default behavior for effects is to fire the effect after every completed render. That way an effect is always recreated if one of its dependencies changes.
 React defers running useEffect until after the browser has painted, so doing extra work is less of a problem.


ğŸ¤”













useStateï¼š= classä¸­çš„stateï¼Œä¸ç”¨åœ¨useEffectä¸­è®¾ç½®

useEffectï¼šç”Ÿå‘½å‘¨æœŸã€‚å®ƒï¼Œå¯åœ¨åŒä¸ªå‡½æ•°ç»„ä»¶ä¸­å¤šæ¬¡å­˜åœ¨ï¼Œæ¯ä¸ªuseEffectä¸­æ˜¯ç›¸å…³åŠŸèƒ½çš„é€»è¾‘

useCallbackï¼šç›®çš„åœ¨äºç¼“å­˜äº†æ¯æ¬¡æ¸²æŸ“æ—¶inline callbackçš„å®ä¾‹ï¼Œé…åˆå­ç»„ä»¶çš„shouldComponentUpdateæˆ–React.memoèƒ½èµ·åˆ°å‡å°‘ä¸å¿…è¦çš„æ¸²æŸ“çš„ä½œç”¨ã€‚è¿™ä¸ªé…å¯¹ä½¿ç”¨ï¼Œç¼ºäº†ä¸€ä¸ªå¯èƒ½å¯¼è‡´æ€§èƒ½ä¸å‡åé™ã€‚
useCallback(fn, inputs) === useMemo(()=>fn, inputs)
ï¼ˆ1ï¼‰é€‚ç”¨äºæ‰€æœ‰åœºæ™¯å—ï¼Ÿ
è‹¥callbackä¾èµ–äºä¸€ä¸ªå˜åŒ–çš„stateï¼Œè¿™ä¸ªcallbackçš„å¼•ç”¨æ˜¯æ— æ³•ç¼“å­˜çš„


React.PureComponent



1ã€è‹¥function æ²¡æœ‰ç”¨åˆ°reactä¸­çš„æ•°æ®æµï¼ˆstateã€propsï¼‰ï¼Œå»ºè®®å°†è¯¥å‡½æ•°å†™åœ¨ç»„ä»¶å¤–ï¼›è‹¥å‡½æ•°æœ‰å‚ä¸reactä¸­çš„æ•°æ®æµï¼Œç”¨useCallback

2ã€fetchDataæ— é™å¾ªç¯çš„åŸå› ï¼š
1ï¼‰ç¼ºä¹ç¬¬äºŒä¸ªå‚æ•°â€”â€”ä¾èµ–é¡¹
2ï¼‰ç¬¬äºŒä¸ªå‚æ•°é¡¹ ç»å¸¸æ”¹å˜

3ã€useCallback
 if you specify deps, all values from inside your component that are used by the effect must be there. Including props, state, functions â€” anything in your component.

 useCallback is essentially like adding another layer of dependency checks. Itâ€™s solving the problem on the other end â€” rather than avoid a function dependency, we make the function itself only change when necessary.

4ã€useReducer
React guarantees the dispatch function to be constant throughout the component lifetime. 
***You may omit dispatch, setState, and useRef container values from the deps because React guarantees them to be static.***




React.memo is equivalent to PureComponent, but it only compares props. 




useRef: å¯ä»¥ä¿å­˜ç‰¹å®šäºæ­¤ç»„ä»¶å®ä¾‹çš„ä»»ä½•å€¼ï¼Œåˆ›å»ºæŒä¹…å¼•ç”¨,å¹¶ä¸”åœ¨æ¸²æŸ“ä¹‹é—´ä¿æŒä¸å˜ã€‚

(useReducer)[https://zhuanlan.zhihu.com/p/69428082]ï¼šUIå’Œä¸šåŠ¡åˆ†å¼€ç»´æŠ¤ï¼›å¯è¯»æ€§å¼ºï¼›è‡ªåŠ¨åŒ–æµ‹è¯•ç”¨ä¾‹å®¹æ˜“æ„å»ºï¼ˆçº¯å‡½æ•°ï¼‰





useMemo:æŠŠâ€œåˆ›å»ºâ€å‡½æ•°å’Œä¾èµ–é¡¹æ•°ç»„ä½œä¸ºå‚æ•°ä¼ å…¥useMemoï¼Œå®ƒä»…ä¼šåœ¨æŸä¸ªä¾èµ–é¡¹æ”¹å˜æ—¶æ‰é‡æ–°è®¡ç®—memoizedå€¼ã€‚è¿™ç§ä¼˜åŒ–æœ‰åŠ©äºé¿å…åœ¨æ¯æ¬¡æ¸²æŸ“æ—¶éƒ½è¿›è¡Œé«˜å¼€é”€çš„è®¡ç®—
***ä¼ å…¥useMemoçš„å‡½æ•°ä¼šåœ¨æ¸²æŸ“æœŸé—´æ‰§è¡Œã€‚è¯·ä¸è¦åœ¨è¿™ä¸ªå‡½æ•°å†…éƒ¨æ‰§è¡Œä¸æ¸²æŸ“æ— å…³çš„æ“ä½œï¼Œè¯¸å¦‚å‰¯ä½œç”¨è¿™ç±»çš„æ“ä½œå±äºuseEffectçš„é€‚ç”¨èŒƒç•´ï¼Œè€Œä¸æ˜¯useMemo***

```ts
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```


useCallbackå’ŒuseMemoçš„äº’è½¬å…³ç³»ï¼šuseCallback(fn, deps) === useMemo(() => fn, deps))

- [ä¸€ç¯‡æ–‡ç« ï¼Œå¸¦ä½ å­¦ä¼šuseRefã€useCallbackã€useMemo](https://zhuanlan.zhihu.com/p/117577458)




# å¤ç”¨ç»„ä»¶é€»è¾‘çš„å‡ ç§æ–¹å¼

## ximin

## é«˜é˜¶ç»„ä»¶
é«˜é˜¶ç»„ä»¶æ˜¯å‡½æ•°ï¼Œå®ƒæ¥æ”¶åŸå§‹ç»„ä»¶ï¼Œå¹¶è¿”å›åŸå§‹ç»„ä»¶å¢å¼º/å¡«å……ç‰ˆæœ¬

```js
const HOC = component => EnhancedComponent;
```

## hook
 hook æ—¨åœ¨è®©ç»„ä»¶çš„å†…éƒ¨é€»è¾‘ç»„ç»‡æˆå¯å¤ç”¨çš„æ›´å°å•å…ƒï¼Œè¿™äº›å•å…ƒå„è‡ªç»´æŠ¤ä¸€éƒ¨åˆ†ç»„ä»¶â€˜çŠ¶æ€å’Œé€»è¾‘â€™ã€‚hookä¸æ˜¯å¼ºåˆ¶åŸºäºç”Ÿå‘½å‘¨æœŸæ–¹æ³•è¿›è¡Œåˆ†å‰²ã€‚


- [typescriptä¸­é«˜çº§ç±»å‹Record](https://blog.csdn.net/weixin_38080573/article/details/92838045)



- [ä½ ä¸çŸ¥é“çš„ useCallbackï¼Œé¿å…æ­»å¾ªç¯](https://segmentfault.com/a/1190000020108840)


- [Reactç»„ä»¶è®¾è®¡å®è·µæ€»ç»“04 - ç»„ä»¶çš„æ€ç»´](https://juejin.cn/post/6844903844711759880#heading-3)




