(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{413:function(t,a,e){t.exports=e.p+"assets/img/20210601003.f8da5bd5.png"},414:function(t,a,e){t.exports=e.p+"assets/img/eventloop20201012001.c4905935.png"},415:function(t,a,e){t.exports=e.p+"assets/img/20210601002.430667ae.png"},416:function(t,a,e){t.exports=e.p+"assets/img/20210601001.82f3cc66.png"},417:function(t,a,e){t.exports=e.p+"assets/img/20210601004.bd837b78.png"},519:function(t,a,e){"use strict";e.r(a);var s=e(46),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("在coding的过程中，我发现很多思想是共通的、类似的、可互相借鉴的，仅以此文记录看到的一些设计：关于 解决页面阻塞渲染 而采取异步措施的 做法。")]),t._v(" "),s("h2",{attrs:{id:"eventloop"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#eventloop"}},[t._v("#")]),t._v(" eventLoop")]),t._v(" "),s("h3",{attrs:{id:"_1-1-背景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-背景"}},[t._v("#")]),t._v(" 1.1 背景")]),t._v(" "),s("p",{attrs:{align:"center"}},[s("img",{attrs:{src:e(413),alt:"20210601003"}})]),t._v("\njs是单线程的，所有任务都要排队等候处理，若有些任务非常耗时，将会一直占用着资源，而且CPU也未得到充分的利用。所以我们先将一些任务先挂起，等有返回结果再进行处理，这时候就要用到Event Loop了。\n"),s("h3",{attrs:{id:"_1-2-定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-定义"}},[t._v("#")]),t._v(" 1.2 定义")]),t._v(" "),s("p",[t._v("Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。")]),t._v(" "),s("p",{attrs:{align:"center"}},[s("img",{attrs:{src:e(414),alt:"eventloop20201012001"}})]),t._v(" "),s("p",[t._v("于是，所有任务可以分成两种：")]),t._v(" "),s("ul",[s("li",[t._v("同步任务（synchronous），指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务")]),t._v(" "),s("li",[t._v("异步任务（asynchronous），指的是，不进入主线程、而进入“任务队列”的任务，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务的返回结果才会进入主线程执行。")])]),t._v(" "),s("blockquote",[s("p",[t._v("几个概念："),s("br"),t._v("主线程main thread。 "),s("br"),t._v("执行栈call-stack：存储函数调用的栈结构，先进后出，所有的任务都会被放到调用栈等待主线程执行。"),s("br"),t._v("任务队列task queue：先进先出，能解决同步任务和异步任务的场景，当遇到异步代码时，会被挂起在任务队列中，一旦执行栈为空，就从task中拿出对应的执行。")])]),t._v(" "),s("p",[t._v("具体来说，异步执行的运行机制如下：")]),t._v(" "),s("ol",[s("li",[t._v("同步任务会按照顺序等待主线程依次执行，形成一个执行栈（execution context stack）")]),t._v(" "),s("li",[t._v("主线程之外，会存在一个任务队列，只要异步任务有了结果，就在任务队列中放置 注册的回调函数。")]),t._v(" "),s("li",[t._v("当主线程空闲的时候（即，执行栈中所有同步任务执行完，调用栈被清空时），就会读取任务队列。那些对应的异步任务，会结束等待状态，进行执行栈，开始执行")]),t._v(" "),s("li",[t._v("主线程不断重复第三步。")])]),t._v(" "),s("p",[t._v("简单版：\n")]),s("p",{attrs:{align:"center"}},[s("img",{attrs:{src:e(415),alt:"20210601002"}})]),s("p"),t._v(" "),s("p",[t._v("复杂版：\n")]),s("p",{attrs:{align:"center"}},[s("img",{attrs:{src:e(416),alt:"20210601001"}})]),s("p"),t._v(" "),s("h3",{attrs:{id:"_1-3-宏任务、微任务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-宏任务、微任务"}},[t._v("#")]),t._v(" 1.3 宏任务、微任务")]),t._v(" "),s("p",[t._v("异步任务分为两种类型：macroTask宏任务和microTask微任务：")]),t._v(" "),s("ul",[s("li",[t._v("macroTask：script(主程序代码),setTimeout, setInterval, setImmediate, I/O, UI rendering")]),t._v(" "),s("li",[t._v("microTask：process.nextTick(node), Promises, Object.observe, MutationObserver")])]),t._v(" "),s("p",[t._v("执行顺序：")]),t._v(" "),s("p",[t._v("首先执行主线程中的同步任务，当主线程中任务执行完毕后，再从event loop中读取任务")]),t._v(" "),s("p",[t._v("event loop读取任务的先后顺序，取决于任务队列job queue中对于不同任务读取规则的限定")]),t._v(" "),s("p",[t._v("假设：macroTask队列包含任务: a1、a2、a3，microTask队列包含任务: b1、 b2 、b3")]),t._v(" "),s("p",[t._v("执行顺序为：首先执行marcoTask队列开头的任务，也就是 a1 任务，执行完毕后，在执行microTask队列里的所有任务，也就是依次执行b1, b2 , b3，执行完后清空microTask中的任务，接着执行marcoTask中的第二个任务a2，依次循环。")]),t._v(" "),s("p",[t._v("简单来说，每一个循环都是一个这样的过程：\n")]),s("p",{attrs:{align:"center"}},[s("img",{attrs:{src:e(417),alt:"20210601004"}})]),s("p"),t._v(" "),s("p",[t._v("真实场景下的：script(主程序代码)—>process.nextTick—>Promises…——>setTimeout——>setInterval——>setImmediate——> I/O——>UI rendering")]),t._v(" "),s("h3",{attrs:{id:"_1-4-学习文档"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-学习文档"}},[t._v("#")]),t._v(" 1.4 学习文档")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==&mid=2649830221&idx=2&sn=80bb5cc0a17a73a2dca5f222bd1ba6ae&chksm=f175f98ec60270984f1507b5744a2302790889c5ce50dba54a98c62d4db11b1612c90e986239&mpshare=1&scene=23&srcid=101002qEoigfog338K3PNHRe&sharer_sharetime=1602305091677&sharer_shareid=240280dad34afa83333ba12be4c57ba8#rd",target:"_blank",rel:"noopener noreferrer"}},[t._v("浏览器是如何调度进程和线程的？"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://juejin.im/post/6844903764202094606",target:"_blank",rel:"noopener noreferrer"}},[t._v("强推：Event Loop"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://blog.csdn.net/liwusen/article/details/79509288",target:"_blank",rel:"noopener noreferrer"}},[t._v("从promise、process.nextTick、setTimeout出发，谈谈Event Loop中的Job queue"),s("OutboundLink")],1)])]),t._v(" "),s("h2",{attrs:{id:"vue的nexttick设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue的nexttick设计"}},[t._v("#")]),t._v(" Vue的nextTick设计")]),t._v(" "),s("p",[t._v("vue中nextTick，官方文档的解释是：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。Vue 2版本它的实现原理就是：")]),t._v(" "),s("ol",[s("li",[t._v("用异步队列的方式来控制DOM更新和nextTick回调先后执行")]),t._v(" "),s("li",[t._v("microTask因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕")]),t._v(" "),s("li",[t._v("因为兼容性问题，vue不得不做了microTask向macroTask的降级方案")])]),t._v(" "),s("p",[t._v("我们在实际开发中，比如从服务端接口获取数据的时候，数据做了修改，如果我们的某些方法去依赖了数据修改后的DOM变化，我们就必须在nextTick后执行，如下：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getData")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("res"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 继清空 前面的microTask队列 之后，将挂在任务队列中的 macroTask之一ajax回调 放到执行栈，主线程继续执行这个ajax回调后的结果。若此时microTask、macroTask都已清空，UI渲染更新。即tick 1")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("xxx "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" res"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("$nextTick")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此处我们是在下一个eventloop / tick 2中获取到的 变化后的dom元素了 ")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这里我们可以获取变化后的 DOM")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("h3",{attrs:{id:"学习文档"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#学习文档"}},[t._v("#")]),t._v(" 学习文档")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://juejin.cn/post/6844903590293684231",target:"_blank",rel:"noopener noreferrer"}},[t._v("全面解析Vue.nextTick实现原理"),s("OutboundLink")],1)])]),t._v(" "),s("h2",{attrs:{id:"react的fiber设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react的fiber设计"}},[t._v("#")]),t._v(" React的Fiber设计")]),t._v(" "),s("p",[t._v("Fiber主要是为了解决其DOM同步的更新过程所带来的界面卡顿问题而设计的。它的主要目标是实现虚拟DOM的增量渲染，能够将渲染工作拆分成块并将其分散到多个帧的能力。在新的更新到来时，能够暂停、中止和复用工作，能为不同类型的更新分配优先级顺序的能力。")]),t._v(" "),s("h3",{attrs:{id:"学习文档-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#学习文档-2"}},[t._v("#")]),t._v(" 学习文档")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/26027085",target:"_blank",rel:"noopener noreferrer"}},[t._v("导入篇 && 背景篇：React Fiber是什么"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://juejin.cn/post/6906676903302709262",target:"_blank",rel:"noopener noreferrer"}},[t._v("启迪篇 && 思路篇：漫谈 React Fiber"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://juejin.cn/post/6859528127010471949",target:"_blank",rel:"noopener noreferrer"}},[t._v("源码篇：React Fiber（v16 版本） 源码解析"),s("OutboundLink")],1)])]),t._v(" "),s("h2",{attrs:{id:"echarts的scheduler"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#echarts的scheduler"}},[t._v("#")]),t._v(" echarts的scheduler")]),t._v(" "),s("p",[t._v("记着，待学习、研究")])])}),[],!1,null,null,null);a.default=r.exports}}]);